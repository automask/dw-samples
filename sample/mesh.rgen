#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

layout (set = 0, binding = 0) uniform accelerationStructureNV Scene;

layout (set = 0, binding = 1, rgba8) uniform image2D OutputImage;

layout (set = 0, binding = 2) uniform PerFrameUBO 
{
	mat4 model;
	mat4 view;
	mat4 projection;
    vec4 cam_pos_fovy;
    vec4 cam_dir_farz;
    vec4 cam_up;
    vec4 cam_right;
} ubo;

layout(location = PRIMARY_RAY_PAYLOAD_LOC) rayPayloadNV RayPayload PrimaryRay;

vec3 calc_ray_dir(vec2 screen_uv, float aspect) 
{
    vec3 u = ubo.cam_right.xyz;
    vec3 v = ubo.cam_up.xyz;

    const float plane_width = tan(ubo.cam_pos_fovy.w * 0.5f);

    u *= (plane_width * aspect);
    v *= plane_width;

    const vec3 ray_dir = normalize(ubo.cam_dir_farz.xyz + (u * screen_uv.x) - (v * screen_uv.y));
    return ray_dir;
}

void main() 
{
    const vec2 cur_pixel = vec2(gl_LaunchIDNV.xy);
    const vec2 bottom_right = vec2(gl_LaunchSizeNV.xy - 1);

    const vec2 uv = (cur_pixel / bottom_right) * 2.0f - 1.0f;

    const float aspect = float(gl_LaunchSizeNV.x) / float(gl_LaunchSizeNV.y);

    vec3 origin = ubo.cam_pos_fovy.xyz;
    vec3 direction = calc_ray_dir(uv, aspect);

    const uint ray_flags = gl_RayFlagsOpaqueNV;
 
    const uint cull_mask = 0xFF;

    const uint stb_record_stride = 1;

    const float tmin = 0.0f;
    const float tmax = ubo.cam_dir_farz.w;

    vec3 final_color = vec3(0.0f);

    traceNV(Scene,
            ray_flags,
            cull_mask,
            0,
            0,
            0,
            origin,
            tmin,
            direction,
            tmax,
            0);

    final_color = PrimaryRay.color_dist.xyz;

    imageStore(OutputImage, ivec2(gl_LaunchIDNV.xy), vec4(final_color, 1.0f));
}